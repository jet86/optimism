{
  "language": "Solidity",
  "sources": {
    "contracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.6.0 <0.8.0;\n\n/**\n * @title ERC20\n * @dev A super simple ERC20 implementation!\n */\ncontract ERC20 {\n\n    /**********\n     * Events *\n     **********/\n\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 _value\n    );\n\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n\n\n    /*************\n     * Variables *\n     *************/\n\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowances;\n\n    // Some optional extra goodies.\n    uint256 public totalSupply;\n    string public name;\n\n\n    /***************\n     * Constructor *\n     ***************/\n\n    /**\n     * @param _initialSupply Initial maximum token supply.\n     * @param _name A name for our ERC20 (technically optional, but it's fun ok jeez).\n     */\n    constructor(\n        uint256 _initialSupply,\n        string memory _name\n    )\n        public\n    {\n        balances[msg.sender] = _initialSupply;\n        totalSupply = _initialSupply;\n        name = _name;\n    }\n\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Checks the balance of an address.\n     * @param _owner Address to check a balance for.\n     * @return Balance of the address.\n     */\n    function balanceOf(\n        address _owner\n    )\n        external\n        view\n        returns (\n            uint256\n        )\n    {\n        return balances[_owner];\n    }\n\n    /**\n     * Transfers a balance from your account to someone else's account!\n     * @param _to Address to transfer a balance to.\n     * @param _amount Amount to transfer to the other account.\n     * @return true if the transfer was successful.\n     */\n    function transfer(\n        address _to,\n        uint256 _amount\n    )\n        external\n        returns (\n            bool\n        )\n    {\n        require(\n            balances[msg.sender] >= _amount,\n            \"You don't have enough balance to make this transfer!\"\n        );\n\n        balances[msg.sender] -= _amount;\n        balances[_to] += _amount;\n\n        emit Transfer(\n            msg.sender,\n            _to,\n            _amount\n        );\n\n        return true;\n    }\n\n    /**\n     * Transfers a balance from someone else's account to another account. You need an allowance\n     * from the sending account for this to work!\n     * @param _from Account to transfer a balance from.\n     * @param _to Account to transfer a balance to.\n     * @param _amount Amount to transfer to the other account.\n     * @return true if the transfer was successful.\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    )\n        external\n        returns (\n            bool\n        )\n    {\n        require(\n            balances[_from] >= _amount,\n            \"Can't transfer from the desired account because it doesn't have enough balance.\"\n        );\n\n        require(\n            allowances[_from][msg.sender] >= _amount,\n            \"Can't transfer from the desired account because you don't have enough of an allowance.\"\n        );\n\n        balances[_to] += _amount;\n        balances[_from] -= _amount;\n\n        emit Transfer(\n            _from,\n            _to,\n            _amount\n        );\n\n        return true;\n    }\n\n    /**\n     * Approves an account to spend some amount from your account.\n     * @param _spender Account to approve a balance for.\n     * @param _amount Amount to allow the account to spend from your account.\n     * @return true if the allowance was successful.\n     */\n    function approve(\n        address _spender,\n        uint256 _amount\n    )\n        external\n        returns (\n            bool\n        )\n    {\n        allowances[msg.sender][_spender] = _amount;\n\n        emit Approval(\n            msg.sender,\n            _spender,\n            _amount\n        );\n\n        return true;\n    }\n\n    /**\n     * Checks how much a given account is allowed to spend from another given account.\n     * @param _owner Address of the account to check an allowance from.\n     * @param _spender Address of the account trying to spend from the owner.\n     * @return Allowance for the spender from the owner.\n     */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        external\n        view\n        returns (\n            uint256\n        )\n    {\n        return allowances[_owner][_spender];\n    }\n}\n"
    },
    "contracts/StableSwap.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\n\n\n/**\n * @title Storage\n * @dev Store & retrieve value in a variable\n */\n\n contract StableSwap {\n\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    uint256 public x;\n    uint256 public y;\n    uint256 public k;\n    uint256 public A;\n\n\n    /**\n     * @dev initialize x tokens, y tokens to form invariant with A = 0\n     * @param _x, _y balances such that val(_x) = val(_y)\n     */\n    constructor(\n        uint256 _x,\n        uint256 _y\n    )\n        public\n    {\n        x = _x;\n        y = _y;\n        k = x.mul(y);\n        A = 0;\n    }\n\n\n    // /**\n    //  * @dev initialize x tokens, y tokens to form invariant with A = 0\n    //  * @param _x, _y balances such that val(_x) = val(_y)\n    //  */\n    // function initializeLiquidity(uint256 _x, uint256 _y) public {\n    //     require(_x > 0 && _y > 0);\n    //     x = _x;\n    //     y = _y;\n    //     k = x*y;\n    //     A = 0;\n    // }\n\n\n    /**\n     * @dev add x tokens, y tokens to update invariant k with same A\n     * @param x_in, y_in balances such that val(x_in) = val(y_in)\n     */\n    function addLiquidity(uint256 x_in, uint256 y_in) public {\n        require(x_in > 0 && y_in > 0);\n        x = x.add(x_in);\n        y = y.add(y_in);\n        k = x.mul(y);\n    }\n\n    /**\n     * @dev remove x tokens, y tokens to update invariant k with same A\n     * @param percOut such that percentage of liquidity removed\n     */\n    function removeLiquidity(uint256 percOut) public returns (uint256 x_back, uint256 y_back) {\n        require(percOut > 0 && percOut <= 100);\n        x_back = (x.mul(percOut)).div(100);\n        y_back = (y.mul(percOut)).div(100);\n        x = x.sub(x_back);\n        y = y.sub(y_back);\n        k = x.mul(y);\n    }\n\n    /**\n     * @dev Change A for Stable Swap equation\n     * @param _A dictating shape of stable swap curve\n     */\n    function changeA(uint256 _A) public {\n        require(A >= 0);\n        A = _A;\n    }\n\n    /**\n     * @dev Square root function\n     * @param a number to find the square root of (rounded down?)\n     * Adapted from https://github.com/ethereum/dapp-bin/pull/50/files (an open PR for solidity)\n     */\n    function sqrt(uint a) public pure returns (uint b) {\n        require(a >= 0);\n        if (a == 0) return 0;\n        else if (a <= 3) return 1;\n        uint c = (a.add(1)).div(2);\n        b = a;\n        while (c < b)\n        /// @why3 invariant { to_int !_a = div ((div (to_int arg_a) (to_int !_b)) + (to_int !_b)) 2 }\n        /// @why3 invariant { to_int arg_a < (to_int !_b + 1) * (to_int !_b + 1) }\n        /// @why3 invariant { to_int arg_a < (to_int !_c + 1) * (to_int !_c + 1) }\n        /// @why3 variant { to_int !_b }\n        {\n            b = c;\n            c = (a.div(c).add(c)).div(2);\n        }\n    }\n\n    /**\n     * @dev Absolute value function\n     * @param d number to find the square root of (rounded down?)\n     * Adapted from https://ethereum.stackexchange.com/questions/84390/absolute-value-in-solidity/\n     */\n    function abs(int256 d) private pure returns (int256 val) {\n        val = ((d >= 0)? d : -d);\n    }\n\n    /**\n     * @dev Safe Power function\n     * @param base, exponent to find base^(exponent)\n     * Adapted from https://forum.openzeppelin.com/t/does-safemath-library-need-a-safe-power-function/871/8\n     */\n    function pow(int256 base, int256 exponent) public pure returns (int256) {\n        if (exponent == 0) {\n            return 1;\n        }\n        else if (exponent == 1) {\n            return base;\n        }\n        else if (base == 0 && exponent != 0) {\n            return 0;\n        }\n        else {\n            int256 z = base;\n            for (int256 i = 1; i < exponent; i++)\n                z = z.mul(base);\n            return z;\n        }\n    }\n\n    /**\n     * @dev Boolean function enforcing stable swap invariant\n     */\n    function invariant() public view returns (bool pass){\n        require(x > 0 && x <= k);\n        require(y > 0 && y <= k);\n        uint256 rootK = sqrt(k);\n        uint256 LHS = (A.mul(4)).mul(x.add(y)).add(rootK.mul(2));\n        uint256 RHS = (A.mul(4)).mul(rootK.mul(2)).add(uint256(pow(int256(rootK.mul(2)),3))).div((x.mul(4)).mul(y));\n        pass = (LHS == RHS);\n    }\n\n    /**\n     * @dev Swap x for y according to stable swap invariant\n     * @param x_in to return y_out\n     */\n    function swap_x(uint256 x_in) public returns (uint256 y_out){\n        uint256 newX = x.add(x_in);\n        uint256 a = A.mul(4);\n        uint256 K = sqrt(k).mul(2);\n        uint256 newY;\n\n        int256 alpha = int256((a.mul(4)).mul(newX));\n        int256 beta = int256((a.mul(4)).mul(uint256(pow(int256(newX),2)))).add(int256((newX.mul(4)).mul(K))).sub(int256(((a.mul(4)).mul(K).mul(newX))));\n        int256 gamma = -(pow(int256(K),3));\n\n        // Solving quadratic\n\n        int256 d = (beta.mul(beta)).sub((alpha.mul(4)).mul(gamma));\n        int256 sqrtD = int256(sqrt(uint256(abs(d))));\n\n        if(d >= 0){\n            int256 root1 = (-beta.add(sqrtD)).div(alpha.mul(2));\n            int256 root2 = (-beta.sub(sqrtD)).div(alpha.mul(2));\n            newY = uint256((root1 > 0 && root1 <= int256(k))? root1 : root2);\n            y_out = y.sub(newY);\n\n            //Changing variables for future\n            x = newY;\n            y = newX;\n            assert(invariant());\n        }\n        else{\n            revert(\"Wrong swap amount provided\");\n        }\n    }\n\n    /**\n     * @dev Swap y for x according to stable swap invariant\n     * @param y_in to return x_out\n     */\n    function swap_y(uint256 y_in) public returns (uint256 x_out){\n        uint256 newY = y.add(y_in);\n        uint256 a = (A.mul(4));\n        uint256 K = sqrt(k).mul(2);\n        uint256 newX;\n\n        int256 alpha = int256((a.mul(4)).mul(newY));\n        int256 beta = int256((a.mul(4)).mul(uint256(pow(int256(newY),2)))).add(int256((newY.mul(4)).mul(K))).sub(int256(((a.mul(4)).mul(K).mul(newY))));\n        int256 gamma = -(pow(int256(K),3));\n\n        // Solving quadratic\n\n        int256 d = (beta.mul(beta)).sub((alpha.mul(4)).mul(gamma));\n        int256 sqrtD = int256(sqrt(uint256(abs(d))));\n\n        if(d >= 0){\n            int256 root1 = (-beta.add(sqrtD)).div(alpha.mul(2));\n            int256 root2 = (-beta.sub(sqrtD)).div(alpha.mul(2));\n            newX = uint256((root1 > 0 && root1 <= int256(k))? root1 : root2);\n            x_out = x.sub(newX);\n\n            //Changing variables for future\n            x = newY;\n            y = newX;\n            assert(invariant());\n        }\n        else{\n            revert(\"Wrong swap amount provided\");\n        }\n    }\n}\n\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}